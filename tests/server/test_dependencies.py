import pytest
import types

from openmcp import MCPServer, Depends, tool
from openmcp.server.dependencies.solver import resolve
import openmcp.context as context_module


@pytest.mark.anyio
async def test_resolve_basic_dependency():
    async def provide_number() -> int:
        return 42

    result = await resolve(Depends(provide_number))
    assert result == 42


@pytest.mark.anyio
async def test_resolve_nested_dependency():
    async def get_account() -> dict[str, str]:
        return {"tier": "pro"}

    def is_pro(account: dict[str, str]) -> bool:
        return account["tier"] == "pro"

    result = await resolve(Depends(is_pro, get_account))
    assert result is True


@pytest.mark.anyio
async def test_dependency_cache(monkeypatch):
    calls = {"count": 0}

    async def expensive_call() -> int:
        calls["count"] += 1
        return calls["count"]

    class DummyContext:
        def __init__(self) -> None:
            self.dependency_cache: dict = {}

    dummy = DummyContext()
    monkeypatch.setattr("openmcp.server.dependencies.solver.get_context", lambda: dummy)

    await resolve(Depends(expensive_call))
    await resolve(Depends(expensive_call))

    assert calls["count"] == 1


@pytest.mark.anyio
async def test_tool_allow_list_dependency():
    from tests.helpers import DummySession, run_with_context

    state = {"tier": "basic"}

    def get_user() -> dict[str, str]:
        return state

    def require_pro(user: dict[str, str]) -> bool:
        return user["tier"] == "pro"

    server = MCPServer("di-demo")

    with server.binding():

        @tool()
        async def basic_tool() -> str:
            return "basic"

        @tool(enabled=Depends(require_pro, get_user))
        async def premium_tool() -> str:
            return "premium"

    session = DummySession("test-session")

    result = await run_with_context(session, server.tools.list_tools, None)
    names_basic = [tool.name for tool in result.tools]
    assert "premium_tool" not in names_basic

    state["tier"] = "pro"
    result = await run_with_context(session, server.tools.list_tools, None)
    names_pro = [tool.name for tool in result.tools]
    assert "premium_tool" in names_pro

    state["tier"] = "basic"
    response = await run_with_context(session, server.tools.call_tool, "premium_tool", {})
    assert response.isError is True

    state["tier"] = "pro"
    response = await run_with_context(session, server.tools.call_tool, "premium_tool", {})
    assert response.isError is False


@pytest.mark.anyio
async def test_dependency_returns_context(monkeypatch):
    dummy_context = types.SimpleNamespace(dependency_cache={})

    monkeypatch.setattr("openmcp.server.dependencies.solver.get_context", lambda: dummy_context)
    monkeypatch.setattr("openmcp.context.get_context", lambda: dummy_context)
    monkeypatch.setattr(
        "tests.server.test_dependencies.framework_get_context",
        lambda: dummy_context,
        raising=False,
    )

    result = await resolve(Depends(context_module.get_context))
    assert result is dummy_context


@pytest.mark.anyio
async def test_tool_injects_context_parameter():
    from tests.helpers import DummySession, run_with_context

    server = MCPServer("context-inject")

    with server.binding():

        @tool()
        async def show_request(ctx=Depends(context_module.get_context)) -> str:
            return ctx.request_id  # type: ignore[return-value]

    session = DummySession("test-session")
    response = await run_with_context(session, server.tools.call_tool, "show_request", {})
    assert response.isError is False
    # Request ID is auto-generated by run_with_context
    assert response.content[0].text.isdigit()  # Should be a numeric request ID


@pytest.mark.anyio
async def test_circular_dependency_detection():
    from openmcp.server.dependencies.models import CircularDependencyError, DependencyCall
    from openmcp.server.dependencies.solver import _resolve_dependency

    # Create a cycle by manually injecting the same object into the seen set
    # This tests the cycle detection mechanism directly
    def dep_a() -> int:
        return 42

    call_a = DependencyCall(dep_a, tuple())

    # Simulate cycle by pre-populating seen with this call's id
    seen = {id(call_a)}

    with pytest.raises(CircularDependencyError, match="Circular dependency detected"):
        await _resolve_dependency(call_a, cache={}, seen=seen)


@pytest.mark.anyio
async def test_dependency_resolution_error_propagation():
    from openmcp.server.dependencies.models import DependencyResolutionError

    def failing_dep() -> int:
        raise ValueError("Intentional failure")

    def uses_failing(val: int) -> str:
        return str(val)

    with pytest.raises(DependencyResolutionError, match="Failed to resolve dependency 'failing_dep'"):
        await resolve(Depends(uses_failing, failing_dep))


@pytest.mark.anyio
async def test_use_cache_false():
    calls = {"count": 0}

    def counting_dep() -> int:
        calls["count"] += 1
        return calls["count"]

    # First call with caching disabled
    result1 = await resolve(Depends(counting_dep, use_cache=False))
    result2 = await resolve(Depends(counting_dep, use_cache=False))

    # Should be called twice since caching is disabled
    assert result1 == 1
    assert result2 == 2
    assert calls["count"] == 2


@pytest.mark.anyio
async def test_auto_inject_context(monkeypatch):
    from openmcp import Context

    dummy_context = types.SimpleNamespace(dependency_cache={}, request_id="auto-inject-123")
    # Patch where solver imports get_context from
    monkeypatch.setattr("openmcp.server.dependencies.solver.get_context", lambda: dummy_context)

    # Define a dependency that expects Context to be auto-injected
    def get_request_id(ctx: Context) -> str:
        return ctx.request_id  # type: ignore[return-value]

    result = await resolve(Depends(get_request_id))
    assert result == "auto-inject-123"


@pytest.mark.anyio
async def test_auto_inject_with_nested_dependencies(monkeypatch):
    from openmcp import Context

    dummy_context = types.SimpleNamespace(dependency_cache={}, request_id="nested-123")
    # Patch where solver imports get_context from
    monkeypatch.setattr("openmcp.server.dependencies.solver.get_context", lambda: dummy_context)

    # Subdependency that uses auto-injection
    def get_prefix(ctx: Context) -> str:
        return f"prefix-{ctx.request_id}"  # type: ignore[return-value]

    # Parent dependency that uses the subdependency
    def build_message(prefix: str) -> str:
        return f"{prefix}-message"

    result = await resolve(Depends(build_message, get_prefix))
    assert result == "prefix-nested-123-message"
